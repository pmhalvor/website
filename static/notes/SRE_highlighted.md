# Site Reliability Engineering (highlighted)

Welcome to the note which pulls the text from an [online Google textbook](https://sre.google/sre-book/table-of-contents), and highlights the objectives in each sentence. The tools used in the background are `spacy`, `bs4`, and basic markdown scripting.  

## Instructions

Run the following cells by clicking on them and pressing `CTRL + ENTER`. 

The next chapters can be loaded by rerunning the last cell. 


```python
! python scrape.py
```

    Subdirectory sre_google already exists



```python
from IPython.display import Markdown as md
from color_chunks import get_colored_chunks
import os

# set directory where book is located
dir_path = 'sre_google/'
os.chdir(dir_path)

# dictionary of book chapters as raw text
book = {}

# read chapters from files (sorted by creation time)
for filename in sorted(os.listdir('.'), key=os.path.getmtime):
    with open(filename, 'r') as f:
        book[filename[:-4]] = f.read()
```


```python
chapters = list(book.keys())
i = 7  # skip unnecessary chapters in the beginning
```


```python
# For each new chapter, press CTRL + ENTER
i += 1
md(get_colored_chunks(book[chapters[i]], markdown=True))
```




<mark><span style="color:green">
              
Service Level Objectives </span></mark>
Written by <mark><span style="color:green">Chris Jones </span></mark>, <mark><span style="color:green">John Wilkes </span></mark>, and <mark><span style="color:green">Niall Murphy </span></mark> with <mark><span style="color:green">Cody SmithEdited </span></mark> by <mark><span style="color:green">Betsy Beyer </span></mark>
<mark><span style="color:green">It </span></mark>’s impossible to manage <mark><span style="color:green">a service </span></mark> correctly, let alone well, without <mark><span style="color:green">understanding </span></mark> which <mark><span style="color:green">behaviors </span></mark> really matter for <mark><span style="color:green">that service </span></mark> and how to measure and evaluate those <mark><span style="color:green">behaviors </span></mark>. To <mark><span style="color:green">this end </span></mark>, <mark><span style="color:green">we </span></mark> would like to define and deliver <mark><span style="color:green">a given level </span></mark> of <mark><span style="color:green">service </span></mark> to <mark><span style="color:green">our users </span></mark>, whether <mark><span style="color:green">they </span></mark> use <mark><span style="color:green">an internal API </span></mark> or <mark><span style="color:green">a public product </span></mark>.
<mark><span style="color:green">We </span></mark> use <mark><span style="color:green">intuition </span></mark>, <mark><span style="color:green">experience </span></mark>, and <mark><span style="color:green">an understanding </span></mark> of <mark><span style="color:green">what </span></mark> <mark><span style="color:green">users </span></mark> want to define <mark><span style="color:green">service level indicators </span></mark> (<mark><span style="color:green">SLIs </span></mark>), <mark><span style="color:green">objectives </span></mark> (<mark><span style="color:green">SLOs </span></mark>), and <mark><span style="color:green">agreements </span></mark> (<mark><span style="color:green">SLAs </span></mark>). <mark><span style="color:green">These measurements </span></mark> describe <mark><span style="color:green">basic properties </span></mark> of <mark><span style="color:green">metrics </span></mark> that matter, <mark><span style="color:green">what values </span></mark> <mark><span style="color:green"><mark><span style="color:green"><mark><span style="color:green">we </span></mark> </span></mark> </span></mark> want those <mark><span style="color:green">metrics </span></mark> to have, and how <mark><span style="color:green"><mark><span style="color:green"><mark><span style="color:green">we </span></mark> </span></mark> </span></mark>’ll react if <mark><span style="color:green"><mark><span style="color:green"><mark><span style="color:green">we </span></mark> </span></mark> </span></mark> can’t provide <mark><span style="color:green">the expected service </span></mark>. Ultimately, choosing <mark><span style="color:green">appropriate metrics </span></mark> helps to drive <mark><span style="color:green">the right action </span></mark> if <mark><span style="color:green">something </span></mark> goes wrong, and also gives <mark><span style="color:green">an SRE team confidence </span></mark> that <mark><span style="color:green">a service </span></mark> is healthy.
<mark><span style="color:green">This chapter </span></mark> describes <mark><span style="color:green">the framework </span></mark> <mark><span style="color:green">we </span></mark> use to wrestle with <mark><span style="color:green">the problems </span></mark> of <mark><span style="color:green">metric modeling </span></mark>, <mark><span style="color:green">metric selection </span></mark>, and <mark><span style="color:green">metric analysis </span></mark>. Much of <mark><span style="color:green">this explanation </span></mark> would be quite abstract without <mark><span style="color:green">an example </span></mark>, so <mark><span style="color:green">we </span></mark>’ll use <mark><span style="color:green">the <mark><span style="color:green">Shakespeare </span></mark> service </span></mark> outlined in <mark><span style="color:green">Shakespeare </span></mark>: <mark><span style="color:green">A Sample Service </span></mark> to illustrate <mark><span style="color:green">our main points </span></mark>.

# <mark><span style="color:green"> </span></mark> <mark><span style="color:green">Service Level Terminology </span></mark>

<mark><span style="color:green">Many readers </span></mark> are likely familiar with <mark><span style="color:green">the concept </span></mark> of <mark><span style="color:green">an <mark><span style="color:green">SLA </span></mark> </span></mark>, but <mark><span style="color:green">the terms </span></mark> <mark><span style="color:green">SLI </span></mark> and <mark><span style="color:green">SLO </span></mark> are also worth careful definition, because in <mark><span style="color:green">common use </span></mark>, the term <mark><span style="color:green">SLA </span></mark> is overloaded and has taken on <mark><span style="color:green">a number </span></mark> of <mark><span style="color:green">meanings </span></mark> depending on <mark><span style="color:green">context </span></mark>. <mark><span style="color:green">We </span></mark> prefer to separate <mark><span style="color:green">those meanings </span></mark> for <mark><span style="color:green">clarity </span></mark>.

# <mark><span style="color:green"> </span></mark># <mark><span style="color:green"> </span></mark> Indicators

<mark><span style="color:green">An SLI </span></mark> is <mark><span style="color:green">a <mark><span style="color:green">service </span></mark> level indicator </span></mark>—<mark><span style="color:green">a carefully defined quantitative measure </span></mark> of <mark><span style="color:green">some aspect </span></mark> of <mark><span style="color:green">the level </span></mark> of <mark><span style="color:green">service </span></mark> that is provided.
<mark><span style="color:green">Most services </span></mark> consider <mark><span style="color:green">request latency </span></mark>—how long <mark><span style="color:green">it </span></mark> takes to return <mark><span style="color:green">a response </span></mark> to <mark><span style="color:green">a request </span></mark>—as <mark><span style="color:green">a key SLI </span></mark>. <mark><span style="color:green">Other common SLIs </span></mark> include <mark><span style="color:green">the error rate </span></mark>, often expressed as <mark><span style="color:green">a fraction </span></mark> of <mark><span style="color:green">all <mark><span style="color:green">requests </span></mark> </span></mark> received, and <mark><span style="color:green">system throughput </span></mark>, typically measured in <mark><span style="color:green">requests </span></mark> per <mark><span style="color:green">second </span></mark>. <mark><span style="color:green">The measurements </span></mark> are often aggregated: i.e., <mark><span style="color:green">raw data </span></mark> is collected over <mark><span style="color:green">a measurement window </span></mark> and then turned into <mark><span style="color:green">a rate </span></mark>, average, or percentile.
Ideally, <mark><span style="color:green">the SLI </span></mark> directly measures <mark><span style="color:green">a service level </span></mark> of <mark><span style="color:green">interest </span></mark>, but sometimes <mark><span style="color:green">only a proxy </span></mark> is available because <mark><span style="color:green">the desired measure </span></mark> may be hard to obtain or interpret. For <mark><span style="color:green">example </span></mark>, <mark><span style="color:green">client-side <mark><span style="color:green">latency </span></mark> </span></mark> is often <mark><span style="color:green">the more user-relevant metric </span></mark>, but <mark><span style="color:green">it </span></mark> might only be possible to measure <mark><span style="color:green">latency </span></mark> at <mark><span style="color:green">the server </span></mark>.
<mark><span style="color:green">Another kind </span></mark> of <mark><span style="color:green">SLI </span></mark> important to <mark><span style="color:green">SREs </span></mark> is <mark><span style="color:green">availability </span></mark>, or <mark><span style="color:green">the fraction </span></mark> of <mark><span style="color:green">the time </span></mark> that <mark><span style="color:green">a service </span></mark> is usable. <mark><span style="color:green">It </span></mark> is often defined in <mark><span style="color:green">terms </span></mark> of <mark><span style="color:green">the fraction </span></mark> of <mark><span style="color:green">well-formed requests </span></mark> that succeed, sometimes called <mark><span style="color:green">yield </span></mark>. (<mark><span style="color:green">Durability </span></mark>—<mark><span style="color:green">the likelihood </span></mark> that <mark><span style="color:green">data </span></mark> will be retained over <mark><span style="color:green">a long period </span></mark> of <mark><span style="color:green">time </span></mark>—is equally important for <mark><span style="color:green">data </span></mark> storage systems.) Although <mark><span style="color:green">100<mark><span style="color:green">% availability </span></mark> </span></mark> is impossible, near-<mark><span style="color:green">100<mark><span style="color:green">% availability </span></mark> </span></mark> is often readily achievable, and <mark><span style="color:green">the industry </span></mark> commonly expresses <mark><span style="color:green">high-availability values </span></mark> in <mark><span style="color:green">terms </span></mark> of <mark><span style="color:green">the number </span></mark> of <mark><span style="color:green">"nines </span></mark>" in <mark><span style="color:green">the availability percentage </span></mark>. For <mark><span style="color:green">example </span></mark>, <mark><span style="color:green">availabilities </span></mark> of <mark><span style="color:green">99% </span></mark> and 99.9<mark><span style="color:green">99% </span></mark> can be referred to as <mark><span style="color:green">"2 nines </span></mark>" and <mark><span style="color:green">"5 nines" availability </span></mark>, respectively, and <mark><span style="color:green">the current published target </span></mark> for <mark><span style="color:green">Google Compute Engine availability </span></mark> is “<mark><span style="color:green">three and a half nines”—99.95% availability </span></mark>.


# <mark><span style="color:green"> </span></mark># <mark><span style="color:green"> </span></mark> Objectives
<mark><span style="color:green">An SLO </span></mark> is <mark><span style="color:green"><mark><span style="color:green">a service level </span></mark> objective </span></mark>: <mark><span style="color:green">a target value </span></mark> or <mark><span style="color:green">range </span></mark> of <mark><span style="color:green">values </span></mark> for <mark><span style="color:green">a service level </span></mark> that is measured by <mark><span style="color:green">an SLI </span></mark>. <mark><span style="color:green">A natural structure </span></mark> for <mark><span style="color:green">SLOs </span></mark> is thus <mark><span style="color:green">SLI </span></mark> ≤ <mark><span style="color:green">target </span></mark>, or lower bound ≤ <mark><span style="color:green">SLI </span></mark> ≤ upper bound. For <mark><span style="color:green">example </span></mark>, <mark><span style="color:green"><mark><span style="color:green">we </span></mark> </span></mark> might decide that <mark><span style="color:green"><mark><span style="color:green">we </span></mark> </span></mark> will return <mark><span style="color:green">Shakespeare search results </span></mark> "quickly," adopting <mark><span style="color:green">an SLO </span></mark> that <mark><span style="color:green">our average search request latency </span></mark> should be <mark><span style="color:green">less than 100 milliseconds </span></mark>.
      Choosing <mark><span style="color:green">an appropriate SLO </span></mark> is complex. To begin with, <mark><span style="color:green">you </span></mark> don’t always get to choose <mark><span style="color:green">its value </span></mark>! For <mark><span style="color:green">incoming HTTP requests </span></mark> from <mark><span style="color:green">the outside world </span></mark> to <mark><span style="color:green"><mark><span style="color:green">you </span></mark>r service </span></mark>, <mark><span style="color:green">the queries </span></mark> per <mark><span style="color:green">second </span></mark> <mark><span style="color:green">(QPS) metric </span></mark> is essentially determined by <mark><span style="color:green">the desires </span></mark> of <mark><span style="color:green"><mark><span style="color:green">you </span></mark>r users </span></mark>, and <mark><span style="color:green">you </span></mark> can’t really set <mark><span style="color:green">an SLO </span></mark> for that.
On <mark><span style="color:green">the other hand </span></mark>, <mark><span style="color:green"><mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> </span></mark> can say that <mark><span style="color:green"><mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> </span></mark> want <mark><span style="color:green">the average latency </span></mark> per <mark><span style="color:green">request </span></mark> to be under <mark><span style="color:green">100 milliseconds </span></mark>, and setting <mark><span style="color:green">such a goal </span></mark> could in <mark><span style="color:green">turn </span></mark> motivate <mark><span style="color:green"><mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> </span></mark> to write <mark><span style="color:green"><mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> </span></mark>r frontend with <mark><span style="color:green">low-latency behaviors </span></mark> of <mark><span style="color:green">various kinds </span></mark> or to buy <mark><span style="color:green">certain kinds </span></mark> of <mark><span style="color:green">low-latency equipment </span></mark>. (<mark><span style="color:green">100 milliseconds </span></mark> is obviously <mark><span style="color:green">an arbitrary value </span></mark>, but in <mark><span style="color:green">general lower latency numbers </span></mark> are good. There are <mark><span style="color:green">excellent reasons </span></mark> to believe that <mark><span style="color:green">fast </span></mark> is better than slow, and that <mark><span style="color:green">user-experienced latency </span></mark> above <mark><span style="color:green">certain values </span></mark> actually drives <mark><span style="color:green">people </span></mark> away— see <mark><span style="color:green">"Speed Matters </span></mark>" <mark><span style="color:green">[Bru09 </span></mark>] for <mark><span style="color:green">more details </span></mark>.)
Again, this is more subtle than <mark><span style="color:green"><mark><span style="color:green">it </span></mark> </span></mark> might at first appear, in that <mark><span style="color:green">those two SLIs—QPS </span></mark> and <mark><span style="color:green">latency </span></mark>—might be connected behind <mark><span style="color:green">the scenes </span></mark>: <mark><span style="color:green">higher QPS </span></mark> often leads to <mark><span style="color:green">larger latencies </span></mark>, and <mark><span style="color:green"><mark><span style="color:green">it </span></mark> </span></mark>’s common for <mark><span style="color:green">services </span></mark> to have <mark><span style="color:green">a performance cliff </span></mark> beyond <mark><span style="color:green">some load threshold </span></mark>.
Choosing and publishing <mark><span style="color:green">SLOs </span></mark> to <mark><span style="color:green">users </span></mark> sets <mark><span style="color:green">expectations </span></mark> about how <mark><span style="color:green">a service </span></mark> will perform. <mark><span style="color:green">This strategy </span></mark> can reduce <mark><span style="color:green">unfounded complaints </span></mark> to service <mark><span style="color:green">owners </span></mark> about, for <mark><span style="color:green">example </span></mark>, <mark><span style="color:green">the service </span></mark> being slow. Without <mark><span style="color:green">an explicit SLO </span></mark>, <mark><span style="color:green">users </span></mark> often develop <mark><span style="color:green">their own beliefs </span></mark> about <mark><span style="color:green">desired performance </span></mark>, which may be unrelated to <mark><span style="color:green">the beliefs </span></mark> held by <mark><span style="color:green">the people </span></mark> designing and operating <mark><span style="color:green">the service </span></mark>. <mark><span style="color:green">This dynamic </span></mark> can lead to both over-<mark><span style="color:green"><mark><span style="color:green">reliance </span></mark> </span></mark> on <mark><span style="color:green">the service </span></mark>, when <mark><span style="color:green">users </span></mark> incorrectly believe that <mark><span style="color:green">a service </span></mark> will be more available than <mark><span style="color:green"><mark><span style="color:green">it </span></mark> </span></mark> actually is (as happened w<mark><span style="color:green"><mark><span style="color:green">it </span></mark> </span></mark>h <mark><span style="color:green">Chubby </span></mark>: see The Global <mark><span style="color:green">Chubby </span></mark> Planned Outage), and under-<mark><span style="color:green"><mark><span style="color:green">reliance </span></mark> </span></mark>, when prospective <mark><span style="color:green">users </span></mark> believe <mark><span style="color:green">a system </span></mark> is flakier and less reliable than <mark><span style="color:green"><mark><span style="color:green">it </span></mark> </span></mark> actually is.

<mark><span style="color:green">The Global Chubby Planned Outage </span></mark>
Written by <mark><span style="color:green">Marc Alvidrez </span></mark>
<mark><span style="color:green">Chubby </span></mark> <mark><span style="color:green">[Bur06 </span></mark>] is Google’s <mark><span style="color:green">lock service </span></mark> for <mark><span style="color:green">loosely coupled distributed systems </span></mark>. In <mark><span style="color:green">the global case </span></mark>, <mark><span style="color:green">we </span></mark> distribute <mark><span style="color:green">Chubby instances </span></mark> such that <mark><span style="color:green">each replica </span></mark> is in <mark><span style="color:green">a different geographical region </span></mark>. Over <mark><span style="color:green">time </span></mark>, <mark><span style="color:green">we </span></mark> found that <mark><span style="color:green">the failures </span></mark> of <mark><span style="color:green">the global instance </span></mark> of <mark><span style="color:green">Chubby </span></mark> consistently generated <mark><span style="color:green">service outages </span></mark>, many of which <mark><span style="color:green">we </span></mark>re visible to end <mark><span style="color:green">users </span></mark>. As <mark><span style="color:green"><mark><span style="color:green">it </span></mark> </span></mark> turns out, <mark><span style="color:green">true global <mark><span style="color:green">Chubby </span></mark> outages </span></mark> are so infrequent that <mark><span style="color:green">service owners </span></mark> began to add <mark><span style="color:green">dependencies </span></mark> to <mark><span style="color:green">Chubby </span></mark> assuming that <mark><span style="color:green"><mark><span style="color:green">it </span></mark> </span></mark> would never go down. <mark><span style="color:green">Its high reliability </span></mark> provided <mark><span style="color:green">a false sense </span></mark> of <mark><span style="color:green">security </span></mark> because <mark><span style="color:green">the services </span></mark> could not function appropriately when <mark><span style="color:green">Chubby </span></mark> was unavailable, however rarely that occurred.
<mark><span style="color:green">The solution </span></mark> to <mark><span style="color:green">this Chubby scenario </span></mark> is interesting: <mark><span style="color:green">SRE </span></mark> makes sure that <mark><span style="color:green">global Chubby </span></mark> meets, but does not significantly exceed, <mark><span style="color:green">its service level objective </span></mark>. In <mark><span style="color:green">any given quarter </span></mark>, if <mark><span style="color:green">a true failure </span></mark> has not dropped <mark><span style="color:green">availability </span></mark> below <mark><span style="color:green">the target </span></mark>, <mark><span style="color:green">a controlled outage </span></mark> will be synthesized by intentionally taking down <mark><span style="color:green">the system </span></mark>. In <mark><span style="color:green">this way </span></mark>, <mark><span style="color:green">we </span></mark> are able to flush out <mark><span style="color:green">unreasonable dependencies </span></mark> on <mark><span style="color:green">Chubby </span></mark> shortly after <mark><span style="color:green">they </span></mark> are added. Doing so <mark><span style="color:green">forces service owners </span></mark> to reckon with <mark><span style="color:green">the reality </span></mark> of <mark><span style="color:green">distributed systems </span></mark> sooner rather than later.Agreements
Finally, <mark><span style="color:green">SLAs </span></mark> are <mark><span style="color:green">service level agreements </span></mark>: <mark><span style="color:green">an explicit or implicit contract </span></mark> with <mark><span style="color:green">your users </span></mark> that includes <mark><span style="color:green">consequences </span></mark> of <mark><span style="color:green">meeting </span></mark> (or missing) <mark><span style="color:green">the SLOs </span></mark> <mark><span style="color:green">they </span></mark> contain. <mark><span style="color:green">The consequences </span></mark> are most easily recognized when <mark><span style="color:green"><mark><span style="color:green">they </span></mark> </span></mark> are financial—<mark><span style="color:green">a rebate </span></mark> or <mark><span style="color:green">a penalty </span></mark>—but <mark><span style="color:green"><mark><span style="color:green">they </span></mark> </span></mark> can take <mark><span style="color:green">other forms </span></mark>. <mark><span style="color:green">An easy way </span></mark> to tell <mark><span style="color:green">the difference </span></mark> between <mark><span style="color:green">an SLO </span></mark> and <mark><span style="color:green">an SLA </span></mark> is to ask "<mark><span style="color:green">what </span></mark> happens if <mark><span style="color:green">the SLOs </span></mark> aren’t met?": if there is <mark><span style="color:green">no explicit consequence </span></mark>, then <mark><span style="color:green">you </span></mark> are almost certainly looking at <mark><span style="color:green">an SLO </span></mark>.16
<mark><span style="color:green">SRE </span></mark> doesn’t typically get involved in constructing <mark><span style="color:green"><mark><span style="color:green">SLAs </span></mark> </span></mark>, because <mark><span style="color:green"><mark><span style="color:green">SLAs </span></mark> </span></mark> are closely tied to <mark><span style="color:green">business and product decisions </span></mark>. <mark><span style="color:green">SRE </span></mark> does, however, get involved in helping to avoid triggering <mark><span style="color:green">the consequences </span></mark> of <mark><span style="color:green">missed SLOs </span></mark>. <mark><span style="color:green">They </span></mark> can also help to define <mark><span style="color:green">the SLIs </span></mark>: there obviously needs to be <mark><span style="color:green">an objective way </span></mark> to measure <mark><span style="color:green">the SLOs </span></mark> in <mark><span style="color:green">the agreement </span></mark>, or <mark><span style="color:green">disagreements </span></mark> will arise.
<mark><span style="color:green">Google <mark><span style="color:green">Search </span></mark> </span></mark> is <mark><span style="color:green">an example </span></mark> of <mark><span style="color:green">an important service </span></mark> that doesn’t have <mark><span style="color:green">an SLA </span></mark> for <mark><span style="color:green">the public </span></mark>: <mark><span style="color:green"><mark><span style="color:green">we </span></mark> </span></mark> want <mark><span style="color:green">everyone </span></mark> to use <mark><span style="color:green">Search </span></mark> as fluidly and efficiently as possible, but <mark><span style="color:green"><mark><span style="color:green">we </span></mark> </span></mark> haven’t signed <mark><span style="color:green">a contract </span></mark> with <mark><span style="color:green">the whole world </span></mark>. Even so, there are still <mark><span style="color:green">consequences </span></mark> if <mark><span style="color:green">Search </span></mark> isn’t available<mark><span style="color:green">—unavailability results </span></mark> in <mark><span style="color:green">a hit </span></mark> to <mark><span style="color:green">our reputation </span></mark>, as well as <mark><span style="color:green">a drop </span></mark> in <mark><span style="color:green">advertising revenue </span></mark>. <mark><span style="color:green">Many other <mark><span style="color:green">Google </span></mark> services </span></mark>, such as <mark><span style="color:green">Google </span></mark> for <mark><span style="color:green">Work </span></mark>, do have <mark><span style="color:green">explicit SLAs </span></mark> with <mark><span style="color:green">their users </span></mark>. Whether or not <mark><span style="color:green">a particular service </span></mark> has <mark><span style="color:green">an SLA </span></mark>, <mark><span style="color:green">it </span></mark>’s valuable to define <mark><span style="color:green">SLIs </span></mark> and <mark><span style="color:green">SLOs </span></mark> and use <mark><span style="color:green">them </span></mark> to manage <mark><span style="color:green">the service </span></mark>.
So much for <mark><span style="color:green">the theory </span></mark>—now for <mark><span style="color:green">the experience </span></mark>.<mark><span style="color:green">Indicators </span></mark> in <mark><span style="color:green">Practice </span></mark>
Given that <mark><span style="color:green">we </span></mark>’ve made <mark><span style="color:green">the case </span></mark> for why choosing <mark><span style="color:green">appropriate <mark><span style="color:green">metrics </span></mark> </span></mark> to measure <mark><span style="color:green"><mark><span style="color:green">you </span></mark>r service </span></mark> is important, how do <mark><span style="color:green">you </span></mark> go about identifying what <mark><span style="color:green">metrics </span></mark> are meaningful to <mark><span style="color:green"><mark><span style="color:green">you </span></mark>r service </span></mark> or <mark><span style="color:green">system </span></mark>?

# <mark><span style="color:green"> </span></mark># <mark><span style="color:green"> </span></mark> What Do <mark><span style="color:green">You </span></mark> and <mark><span style="color:green">You </span></mark>r Users Care About?

<mark><span style="color:green">You </span></mark> shouldn’t use <mark><span style="color:green">every metric </span></mark> <mark><span style="color:green">you </span></mark> can track in <mark><span style="color:green">you </span></mark>r monitoring system as <mark><span style="color:green">an SLI </span></mark>; <mark><span style="color:green">an understanding </span></mark> of <mark><span style="color:green">what </span></mark> <mark><span style="color:green">you </span></mark>r users want from <mark><span style="color:green">the system </span></mark> will inform <mark><span style="color:green">the judicious selection </span></mark> of <mark><span style="color:green">a few indicators </span></mark>. Choosing <mark><span style="color:green">too many indicators </span></mark> makes <mark><span style="color:green">it </span></mark> hard to pay <mark><span style="color:green">the right level </span></mark> of <mark><span style="color:green">attention </span></mark> to <mark><span style="color:green">the indicators </span></mark> that matter, while choosing too few may leave <mark><span style="color:green">significant behaviors </span></mark> of <mark><span style="color:green">your system </span></mark> unexamined. <mark><span style="color:green">We </span></mark> typically find that <mark><span style="color:green">a handful </span></mark> of <mark><span style="color:green">representative indicators </span></mark> are enough to evaluate and reason about <mark><span style="color:green">a system </span></mark>’s <mark><span style="color:green">health </span></mark>.
<mark><span style="color:green">Services </span></mark> tend to fall into <mark><span style="color:green">a few broad categories </span></mark> in <mark><span style="color:green">terms </span></mark> of <mark><span style="color:green">the SLIs </span></mark> <mark><span style="color:green">they </span></mark> find relevant:


<mark><span style="color:green">User-facing serving systems </span></mark>, such as the Shakespeare search frontends, generally care about <mark><span style="color:green">availability </span></mark>, <mark><span style="color:green">latency </span></mark>, and <mark><span style="color:green">throughput </span></mark>. In <mark><span style="color:green">other words </span></mark>: Could <mark><span style="color:green">we </span></mark> respond to <mark><span style="color:green">the request </span></mark>? How long did <mark><span style="color:green">it </span></mark> take to respond? <mark><span style="color:green">How many requests </span></mark> could be handled?


<mark><span style="color:green">Storage systems </span></mark> often emphasize <mark><span style="color:green">latency </span></mark>, <mark><span style="color:green">availability </span></mark>, and <mark><span style="color:green">durability </span></mark>. In <mark><span style="color:green">other words </span></mark>: How long does <mark><span style="color:green">it </span></mark> take to read or wr<mark><span style="color:green">it </span></mark>e <mark><span style="color:green">data </span></mark>? Can <mark><span style="color:green">we </span></mark> access <mark><span style="color:green">the data </span></mark> on <mark><span style="color:green">demand </span></mark>? Is <mark><span style="color:green">the data </span></mark> still there when <mark><span style="color:green">we </span></mark> need <mark><span style="color:green">it </span></mark>? See <mark><span style="color:green">Data Integrity </span></mark>: <mark><span style="color:green"><mark><span style="color:green">What </span></mark> </span></mark> <mark><span style="color:green"><mark><span style="color:green">You </span></mark> </span></mark> Read Is <mark><span style="color:green"><mark><span style="color:green">What </span></mark> </span></mark> <mark><span style="color:green"><mark><span style="color:green">You </span></mark> </span></mark> Wrote for <mark><span style="color:green">an extended discussion </span></mark> of <mark><span style="color:green">these issues </span></mark>.


<mark><span style="color:green">Big data systems </span></mark>, such as <mark><span style="color:green">data processing pipelines </span></mark>, t<mark><span style="color:green">end </span></mark> to care about <mark><span style="color:green">throughput </span></mark> and <mark><span style="color:green">end </span></mark>-to-<mark><span style="color:green">end </span></mark> latency. In <mark><span style="color:green">other words </span></mark>: <mark><span style="color:green">How much data </span></mark> is being processed? How long does <mark><span style="color:green">it </span></mark> take <mark><span style="color:green">the data </span></mark> to progress from <mark><span style="color:green">ingestion </span></mark> to <mark><span style="color:green">completion </span></mark>? (<mark><span style="color:green">Some pipelines </span></mark> may also have <mark><span style="color:green">targets </span></mark> for <mark><span style="color:green">latency </span></mark> on <mark><span style="color:green">individual processing stages </span></mark>.)


<mark><span style="color:green">All systems </span></mark> should care about <mark><span style="color:green">correctness </span></mark>: was <mark><span style="color:green">the right answer </span></mark> returned, <mark><span style="color:green">the right data </span></mark> retrieved, <mark><span style="color:green">the right analysis </span></mark> done? <mark><span style="color:green">Correctness </span></mark> is important to track as <mark><span style="color:green">an indicator </span></mark> of <mark><span style="color:green">system health </span></mark>, even though <mark><span style="color:green">it </span></mark>’s often <mark><span style="color:green">a property </span></mark> of <mark><span style="color:green">the data </span></mark> in <mark><span style="color:green">the system </span></mark> rather than <mark><span style="color:green">the infrastructure </span></mark> per se, and so usually not an SRE responsibil<mark><span style="color:green">it </span></mark>y to meet.
Collecting <mark><span style="color:green">Indicators </span></mark>
<mark><span style="color:green">Many indicator metrics </span></mark> are most naturally gathered on <mark><span style="color:green">the server side </span></mark>, using <mark><span style="color:green">a monitoring system </span></mark> such as <mark><span style="color:green">Borgmon </span></mark> (see <mark><span style="color:green">Practical Alerting </span></mark> from <mark><span style="color:green">Time-Series Data </span></mark>) or <mark><span style="color:green">Prometheus </span></mark>, or with <mark><span style="color:green">periodic log analysis </span></mark>—for <mark><span style="color:green">instance </span></mark>, HTTP <mark><span style="color:green">500 responses </span></mark> as <mark><span style="color:green">a fraction </span></mark> of <mark><span style="color:green">all requests </span></mark>. However, <mark><span style="color:green">some systems </span></mark> should be instrumented with <mark><span style="color:green">client-side collection </span></mark>, because not measuring <mark><span style="color:green">behavior </span></mark> at <mark><span style="color:green">the client </span></mark> can miss <mark><span style="color:green">a range </span></mark> of <mark><span style="color:green">problems </span></mark> that affect <mark><span style="color:green">users </span></mark> but don’t affect <mark><span style="color:green">server-side metrics </span></mark>. For <mark><span style="color:green">example </span></mark>, concentrating on <mark><span style="color:green">the response latency </span></mark> of <mark><span style="color:green">the Shakespeare search backend </span></mark> might miss <mark><span style="color:green">poor user latency </span></mark> due to <mark><span style="color:green">problems </span></mark> w<mark><span style="color:green">it </span></mark>h <mark><span style="color:green">the page </span></mark>’s <mark><span style="color:green">JavaScript </span></mark>: in <mark><span style="color:green">this case </span></mark>, measuring how long <mark><span style="color:green">it </span></mark> takes for <mark><span style="color:green">a page </span></mark> to become usable in <mark><span style="color:green">the browser </span></mark> is <mark><span style="color:green">a better proxy </span></mark> for <mark><span style="color:green">what </span></mark> <mark><span style="color:green">the user </span></mark> actually experiences.


# <mark><span style="color:green"> </span></mark># <mark><span style="color:green"> </span></mark> Aggregation

For <mark><span style="color:green">simplicity </span></mark> and <mark><span style="color:green">usability </span></mark>, <mark><span style="color:green">we </span></mark> often aggregate <mark><span style="color:green">raw measurements </span></mark>. This needs to be done carefully.
<mark><span style="color:green">Some metrics </span></mark> are seemingly straightforward, like <mark><span style="color:green">the number </span></mark> of <mark><span style="color:green">requests </span></mark> per second served, but <mark><span style="color:green">even this apparently straightforward measurement </span></mark> implicitly aggregates <mark><span style="color:green">data </span></mark> over <mark><span style="color:green">the measurement window </span></mark>. Is <mark><span style="color:green">the measurement </span></mark> obtained once a second, or by averaging <mark><span style="color:green">requests </span></mark> over <mark><span style="color:green">a minute </span></mark>? The latter may hide <mark><span style="color:green">much higher instantaneous request rates </span></mark> in <mark><span style="color:green">bursts </span></mark> that last for <mark><span style="color:green">only a few seconds </span></mark>. Consider <mark><span style="color:green">a system </span></mark> that serves <mark><span style="color:green">200 requests </span></mark><mark><span style="color:green">/s </span></mark> in <mark><span style="color:green">even-numbered seconds </span></mark>, and 0 in <mark><span style="color:green">the others </span></mark>. <mark><<mark><span style="color:green">s </span></mark>pan <mark><span style="color:green">s </span></mark>tyle="color:green">It </<mark><span style="color:green">s </span></mark>pan></mark> ha<mark><span style="color:green">s </span></mark> <mark><<mark><span style="color:green">s </span></mark>pan <mark><span style="color:green">s </span></mark>tyle="color:green">the <mark><span style="color:green">s </span></mark>ame average load </<mark><span style="color:green">s </span></mark>pan></mark> a<mark><span style="color:green">s </span></mark> one that <mark><span style="color:green">s </span></mark>erve<mark><span style="color:green">s </span></mark> <mark><<mark><span style="color:green">s </span></mark>pan <mark><span style="color:green">s </span></mark>tyle="color:green">a con<mark><span style="color:green">s </span></mark>tant 100 reque<mark><span style="color:green">s </span></mark>t<mark><span style="color:green">s </span></mark> </<mark><span style="color:green">s </span></mark>pan></mark>/<mark><span style="color:green">s </span></mark>, but ha<mark><span style="color:green">s </span></mark> an in<mark><span style="color:green">s </span></mark>tantaneou<mark><span style="color:green">s </span></mark> load that i<mark><span style="color:green">s </span></mark> twice a<mark><span style="color:green">s </span></mark> large a<mark><span style="color:green">s </span></mark> the average one. Similarly, averaging <mark><span style="color:green">request latencies </span></mark> may seem attractive, but obscures <mark><span style="color:green">an important detail </span></mark>: <mark><span style="color:green">it </span></mark>’s entirely possible for most of <mark><span style="color:green">the <mark><span style="color:green">requests </span></mark> </span></mark> to be fast, but for <mark><span style="color:green">a long tail </span></mark> of <mark><span style="color:green">requests </span></mark> to be much, much slower.
<mark><span style="color:green">Most metrics </span></mark> are better thought of as <mark><span style="color:green">distributions </span></mark> rather than <mark><span style="color:green">averages </span></mark>. For <mark><span style="color:green">example </span></mark>, for <mark><span style="color:green">a latency SLI </span></mark>, <mark><span style="color:green">some requests </span></mark> will be serviced quickly, while <mark><span style="color:green">others </span></mark> will invariably take longer—sometimes much longer. <mark><span style="color:green">A simple average </span></mark> can obscure <mark><span style="color:green">these tail latencies </span></mark>, as well as <mark><span style="color:green">changes </span></mark> in <mark><span style="color:green">them </span></mark>. <mark><span style="color:green">Figure </span></mark> 4-1 provides <mark><span style="color:green">an example </span></mark>: although <mark><span style="color:green">a typical request </span></mark> is served in <mark><span style="color:green">about 50 ms </span></mark>, <mark><span style="color:green">5% </span></mark> of <mark><span style="color:green">requests </span></mark> are 20 times slower! <mark><span style="color:green">Monitoring </span></mark> and alerting based only on <mark><span style="color:green">the average latency </span></mark> would show <mark><span style="color:green">no change </span></mark> in <mark><span style="color:green">behavior </span></mark> over <mark><span style="color:green">the course </span></mark> of <mark><span style="color:green">the day </span></mark>, when there are in <mark><span style="color:green">fact </span></mark> <mark><span style="color:green">significant changes </span></mark> in <mark><span style="color:green">the tail latency </span></mark> (<mark><span style="color:green">the topmost line </span></mark>).


<mark><span style="color:green">Figure </span></mark> 4-1. 50th, 85th, 95th, and <mark><span style="color:green">99th </span></mark> percentile latencies for <mark><span style="color:green">a system </span></mark>. Note that <mark><span style="color:green">the Y-axis </span></mark> has <mark><span style="color:green">a logarithmic scale </span></mark>.

Using <mark><span style="color:green">percentiles </span></mark> for <mark><span style="color:green">indicators </span></mark> allows <mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> to consider <mark><span style="color:green">the shape </span></mark> of <mark><span style="color:green">the distribution </span></mark> and <mark><span style="color:green">its differing attributes </span></mark>: <mark><span style="color:green">a high-order percentile </span></mark>, such as <mark><span style="color:green">the 99th </span></mark> or <mark><span style="color:green">99.9th </span></mark>, shows <mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> a plausible worst-case value, while using <mark><span style="color:green">the 50th percentile </span></mark> (also known as <mark><span style="color:green">the median </span></mark>) emphasizes <mark><span style="color:green">the typical case </span></mark>. <mark><span style="color:green">The higher the variance </span></mark> in <mark><span style="color:green">response times </span></mark>, <mark><span style="color:green">the more the typical user experience </span></mark> is affected by <mark><span style="color:green">long-tail behavior </span></mark>, <mark><span style="color:green">an effect </span></mark> exacerbated at <mark><span style="color:green">high load </span></mark> by <mark><span style="color:green">queuing effects </span></mark>. <mark><span style="color:green">User studies </span></mark> have shown that <mark><span style="color:green">people </span></mark> typically prefer <mark><span style="color:green">a slightly slower system </span></mark> to one with <mark><span style="color:green">high variance </span></mark> in <mark><span style="color:green">response time </span></mark>, so <mark><span style="color:green">some SRE teams </span></mark> focus only on <mark><span style="color:green">high percentile values </span></mark>, on <mark><span style="color:green">the grounds </span></mark> that if <mark><span style="color:green">the 99.9th percentile behavior </span></mark> is good, then <mark><span style="color:green">the typical experience </span></mark> is certainly going to be.

<mark><span style="color:green">A Note </span></mark> on <mark><span style="color:green">Statistical Fallacies </span></mark>
<mark><span style="color:green">We </span></mark> generally prefer to work with <mark><span style="color:green">percentiles </span></mark> rather than the mean (arithmetic average) of <mark><span style="color:green">a set </span></mark> of <mark><span style="color:green">values </span></mark>. Doing so makes <mark><span style="color:green">it </span></mark> possible to consider <mark><span style="color:green">the long tail </span></mark> of <mark><span style="color:green">data points </span></mark>, which often have <mark><span style="color:green">significantly different (and more interesting) characteristics </span></mark> than <mark><span style="color:green">the average </span></mark>. Because of <mark><span style="color:green">the artificial nature </span></mark> of <mark><span style="color:green">computing systems </span></mark>, <mark><span style="color:green">data points </span></mark> are often skewed—for <mark><span style="color:green">instance </span></mark>, <mark><span style="color:green">no request </span></mark> can have <mark><span style="color:green">a response </span></mark> in <mark><span style="color:green">less than 0 ms </span></mark>, and <mark><span style="color:green">a timeout </span></mark> at 1,000 ms means that there can be <mark><span style="color:green">no successful responses </span></mark> with <mark><span style="color:green">values </span></mark> greater than <mark><span style="color:green">the timeout </span></mark>. As <mark><span style="color:green">a result </span></mark>, <mark><span style="color:green">we </span></mark> cannot assume that <mark><span style="color:green">the mean </span></mark> and <mark><span style="color:green">the median </span></mark> are the same—or even close to each other!
<mark><span style="color:green">We </span></mark> try not to assume that <mark><span style="color:green">our data </span></mark> is normally distributed w<mark><span style="color:green">it </span></mark>hout verifying <mark><span style="color:green">it </span></mark> first, in <mark><span style="color:green">case </span></mark> some standard intu<mark><span style="color:green">it </span></mark>ions and <mark><span style="color:green">approximations </span></mark> don’t hold. For <mark><span style="color:green">example </span></mark>, if <mark><span style="color:green">the distribution </span></mark> is not <mark><span style="color:green">what </span></mark>’s expected, <mark><span style="color:green">a process </span></mark> that takes <mark><span style="color:green">action </span></mark> when <mark><span style="color:green">it </span></mark> sees <mark><span style="color:green">outliers </span></mark> (e.g., restarting <mark><span style="color:green">a server </span></mark> w<mark><span style="color:green">it </span></mark>h <mark><span style="color:green">high request latencies </span></mark>) may do this too often, or not often enough.Standardize <mark><span style="color:green">Indicators </span></mark>
<mark><span style="color:green">We </span></mark> recommend that <mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> standardize on <mark><span style="color:green">common definitions </span></mark> for <mark><span style="color:green">SLIs </span></mark> so that <mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> don’t have to reason about <mark><span style="color:green">them </span></mark> from <mark><span style="color:green">first principles </span></mark> each time. Any feature that conforms to the standard definition templates can be omitted from the specification of an individual SLI, e.g.:

# <mark><span style="color:green"> </span></mark># <mark><span style="color:green"> </span></mark> Aggregation
 intervals: “Averaged over 1 minute”
<mark><span style="color:green">Aggregation regions </span></mark>: “<mark><span style="color:green">All the tasks </span></mark> in <mark><span style="color:green">a cluster </span></mark>”
How frequently <mark><span style="color:green">measurements </span></mark> are made: “<mark><span style="color:green">Every 10 seconds </span></mark>”
<mark><span style="color:green">Which requests </span></mark> are included: “<mark><span style="color:green">HTTP GETs </span></mark> from <mark><span style="color:green">black-box monitoring jobs </span></mark>”
How <mark><span style="color:green">the data </span></mark> is acquired: “Through <mark><span style="color:green">our mon<mark><span style="color:green">it </span></mark>oring </span></mark>, measured at <mark><span style="color:green">the server </span></mark>”
Data-access latency: “<mark><span style="color:green">Time </span></mark> to <mark><span style="color:green">last byte </span></mark>”

To save <mark><span style="color:green">effort </span></mark>, build <mark><span style="color:green">a set </span></mark> of <mark><span style="color:green">reusable SLI templates </span></mark> for <mark><span style="color:green">each common metric </span></mark>; these also make <mark><span style="color:green">it </span></mark> simpler for <mark><span style="color:green">everyone </span></mark> to understand <mark><span style="color:green">what </span></mark> a specific SLI means.<mark><span style="color:green">Objectives </span></mark> in <mark><span style="color:green">Practice </span></mark>
Start by thinking about (or finding out!) <mark><span style="color:green"><mark><span style="color:green">what </span></mark> </span></mark> <mark><span style="color:green"><mark><span style="color:green">you </span></mark>r users </span></mark> care about, not <mark><span style="color:green"><mark><span style="color:green">what </span></mark> </span></mark> <mark><span style="color:green">you </span></mark> can measure. Often, <mark><span style="color:green">what </span></mark> <mark><span style="color:green"><mark><span style="color:green">you </span></mark>r users </span></mark> care about is difficult or impossible to measure, so <mark><span style="color:green">you </span></mark>’ll end up <mark><span style="color:green">approximating users’ needs </span></mark> in <mark><span style="color:green">some way </span></mark>. However, if <mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> simply start with <mark><span style="color:green">what </span></mark>’s easy to measure, <mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark>’ll end up with <mark><span style="color:green">less useful SLOs </span></mark>. As <mark><span style="color:green">a result </span></mark>, <mark><span style="color:green">we </span></mark>’ve sometimes found that working from <mark><span style="color:green">desired objectives </span></mark> backward to <mark><span style="color:green">specific <mark><span style="color:green">indicators </span></mark> </span></mark> works better than choosing <mark><span style="color:green">indicators </span></mark> and then coming up with <mark><span style="color:green">targets </span></mark>.

# <mark><span style="color:green"> </span></mark># <mark><span style="color:green"> </span></mark> Defining Objectives

For <mark><span style="color:green">maximum clarity </span></mark>, <mark><span style="color:green">SLOs </span></mark> should specify how <mark><span style="color:green"><mark><span style="color:green">they </span></mark> </span></mark>’re measured and the conditions under which <mark><span style="color:green"><mark><span style="color:green">they </span></mark> </span></mark>’re valid. For <mark><span style="color:green">instance </span></mark>, <mark><span style="color:green">we </span></mark> might say the following (<mark><span style="color:green">the second line </span></mark> is the same as the first, but relies on <mark><span style="color:green">the SLI defaults </span></mark> of <mark><span style="color:green">the previous section </span></mark> to remove <mark><span style="color:green">redundancy </span></mark>):

<mark><span style="color:green">99% </span></mark> (averaged <mark><span style="color:green">over 1 minute </span></mark>) of <mark><span style="color:green">Get </span></mark> <mark><span style="color:green">RPC calls </span></mark> will complete in <mark><span style="color:green">less than 100 ms </span></mark> (measured across <mark><span style="color:green">all the backend servers </span></mark>).
<mark><span style="color:green">99% </span></mark> of <mark><span style="color:green">Get RPC calls </span></mark> will complete in <mark><span style="color:green">less than 100 ms. </span></mark>

If <mark><span style="color:green">the shape </span></mark> of <mark><span style="color:green">the performance curves </span></mark> are important, then <mark><span style="color:green">you </span></mark> can specify <mark><span style="color:green">multiple SLO targets </span></mark>:

<mark><span style="color:green">90% </span></mark> of <mark><span style="color:green"><mark><span style="color:green">Get RPC calls </span></mark> </span></mark> will complete in less than 1 ms.
<mark><span style="color:green">99% </span></mark> of <mark><span style="color:green"><mark><span style="color:green">Get RPC calls </span></mark> </span></mark> will complete in <mark><span style="color:green">less than 10 ms. </span></mark>
<mark><span style="color:green">99.9% </span></mark> of <mark><span style="color:green">Get RPC calls </span></mark> will complete in less than 100 ms.

If <mark><span style="color:green">you </span></mark> have <mark><span style="color:green">users </span></mark> w<mark><span style="color:green">it </span></mark>h <mark><span style="color:green">heterogeneous <mark><span style="color:green">workload </span></mark>s </span></mark> such as <mark><span style="color:green">a bulk processing pipeline </span></mark> that cares about <mark><span style="color:green">throughput </span></mark> and <mark><span style="color:green">an interactive client </span></mark> that cares about <mark><span style="color:green">latency </span></mark>, <mark><span style="color:green">it </span></mark> may be appropriate to define <mark><span style="color:green">separate objectives </span></mark> for <mark><span style="color:green">each class </span></mark> of <mark><span style="color:green">workload </span></mark>:

<mark><span style="color:green">95% </span></mark> of <mark><span style="color:green">throughput </span></mark> clients’ Set RPC calls will complete in < <mark><span style="color:green">1 s. </span></mark>
<mark><span style="color:green">99% </span></mark> of latency clients’ Set RPC calls with <mark><span style="color:green">payloads </span></mark> <mark><span style="color:green">< 1 kB </span></mark> will complete in < 10 ms.

<mark><span style="color:green">It </span></mark>’s both unrealistic and undesirable to insist that <mark><span style="color:green">SLOs </span></mark> will be met 100% of <mark><span style="color:green">the time </span></mark>: doing so can reduce <mark><span style="color:green">the rate </span></mark> of <mark><span style="color:green">innovation </span></mark> and <mark><span style="color:green">deployment </span></mark>, require <mark><span style="color:green">expensive, overly conservative solutions </span></mark>, or both. Instead, <mark><span style="color:green">it </span></mark> is better to allow <mark><span style="color:green">an error budget </span></mark>—<mark><span style="color:green">a rate </span></mark> at which <mark><span style="color:green">the SLOs </span></mark> can be missed—and track that on <mark><span style="color:green">a daily or weekly basis </span></mark>. <mark><span style="color:green">Upper management </span></mark> will probably want <mark><span style="color:green">a monthly or quarterly assessment </span></mark>, too. (<mark><span style="color:green">An error budget </span></mark> is <mark><span style="color:green">just an SLO </span></mark> for meeting <mark><span style="color:green">other SLOs </span></mark>!)
<mark><span style="color:green">The SLO violation rate </span></mark> can be compared against <mark><span style="color:green">the error budget </span></mark> (see <mark><span style="color:green">Motivation </span></mark> for <mark><span style="color:green">Error Budgets </span></mark>), with <mark><span style="color:green">the gap </span></mark> used as <mark><span style="color:green">an input </span></mark> to <mark><span style="color:green">the process </span></mark> that decides when to roll out <mark><span style="color:green">new releases </span></mark>.


# <mark><span style="color:green"> </span></mark># <mark><span style="color:green"> </span></mark> Choosing Targets

Choosing targets (SLOs) is not a purely technical activity because of the product and business implications, which should be reflected in both the SLIs and SLOs (and maybe SLAs) that are selected. Similarly, <mark><span style="color:green">it </span></mark> may be necessary to trade off certain product attributes against <mark><span style="color:green">others </span></mark> w<mark><span style="color:green">it </span></mark>hin <mark><span style="color:green">the constraints </span></mark> posed by <mark><span style="color:green">staffing </span></mark>, <mark><span style="color:green">time </span></mark> to <mark><span style="color:green">market </span></mark>, hardware availabil<mark><span style="color:green">it </span></mark>y, and <mark><span style="color:green">funding </span></mark>. While <mark><span style="color:green">SRE </span></mark> should be <mark><span style="color:green">part </span></mark> of <mark><span style="color:green">this conversation </span></mark>, and advise on <mark><span style="color:green">the risks </span></mark> and <mark><span style="color:green">viability </span></mark> of <mark><span style="color:green">different options </span></mark>, <mark><span style="color:green">we </span></mark>’ve learned <mark><span style="color:green">a few lessons </span></mark> that can help make this a more productive discussion:

Don’t pick <mark><span style="color:green">a target </span></mark> based on <mark><span style="color:green">current performance </span></mark>
While understanding <mark><span style="color:green">the merits </span></mark> and <mark><span style="color:green">limits </span></mark> of <mark><span style="color:green"><mark><span style="color:green">a system </span></mark> </span></mark> is essential, adopting <mark><span style="color:green">values </span></mark> without <mark><span style="color:green">reflection </span></mark> may lock <mark><span style="color:green">you </span></mark> into supporting <mark><span style="color:green"><mark><span style="color:green">a system </span></mark> </span></mark> that requires <mark><span style="color:green">heroic efforts </span></mark> to meet <mark><span style="color:green">its targets </span></mark>, and that cannot be improved without <mark><span style="color:green">significant redesign </span></mark>.
Keep <mark><span style="color:green">it </span></mark> simple
<mark><span style="color:green">Complicated aggregations </span></mark> in <mark><span style="color:green">SLIs </span></mark> can obscure <mark><span style="color:green">changes </span></mark> to <mark><span style="color:green">system performance </span></mark>, and are also harder to reason about.
Avoid <mark><span style="color:green">absolutes </span></mark>
While <mark><span style="color:green">it </span></mark>’s tempting to ask for <mark><span style="color:green">a system </span></mark> that can scale <mark><span style="color:green">it </span></mark>s load "infin<mark><span style="color:green">it </span></mark>ely" w<mark><span style="color:green">it </span></mark>hout <mark><span style="color:green">any latency increase </span></mark> and that is "always" available, <mark><span style="color:green">this requirement </span></mark> is unrealistic. <mark><span style="color:green">Even a system </span></mark> that approaches <mark><span style="color:green">such ideals </span></mark> will probably take <mark><span style="color:green">a long time </span></mark> to design and build, and will be expensive to operate—and probably turn out to be unnecessarily better than <mark><span style="color:green">what </span></mark> <mark><span style="color:green">users </span></mark> would be happy (or even delighted) to have.
Have <mark><span style="color:green">as few SLOs </span></mark> as possible
Choose <mark><span style="color:green">just enough SLOs </span></mark> to provide <mark><span style="color:green">good coverage </span></mark> of <mark><span style="color:green">your system </span></mark>’s <mark><span style="color:green">attributes </span></mark>. Defend <mark><span style="color:green">the SLOs </span></mark> <mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> pick: if <mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> can’t ever win <mark><span style="color:green">a conversation </span></mark> about <mark><span style="color:green">prior<mark><span style="color:green">it </span></mark>ies </span></mark> by quoting <mark><span style="color:green">a particular SLO </span></mark>, <mark><span style="color:green">it </span></mark>’s probably not worth having <mark><span style="color:green">that SLO.17 </span></mark> However, <mark><span style="color:green">not all product attributes </span></mark> are amenable to <mark><span style="color:green">SLOs </span></mark>: <mark><span style="color:green">it </span></mark>’s hard to specify <mark><span style="color:green">"user delight </span></mark>" w<mark><span style="color:green">it </span></mark>h <mark><span style="color:green">an SLO </span></mark>.
<mark><span style="color:green">Perfection </span></mark> can wait
<mark><span style="color:green">You </span></mark> can always refine <mark><span style="color:green">SLO definitions </span></mark> and <mark><span style="color:green">targets </span></mark> over <mark><span style="color:green">time </span></mark> as <mark><span style="color:green">you </span></mark> learn about <mark><span style="color:green">a system </span></mark>’s <mark><span style="color:green">behavior </span></mark>. <mark><span style="color:green">It </span></mark>’s better to start w<mark><span style="color:green">it </span></mark>h <mark><span style="color:green">a loose target </span></mark> that <mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> tighten than to choose <mark><span style="color:green">an overly strict target </span></mark> that has to be relaxed when <mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> discover <mark><span style="color:green">it </span></mark>’s unattainable.

<mark><span style="color:green">SLOs </span></mark> can—and should—be <mark><span style="color:green">a major driver </span></mark> in prioritizing <mark><span style="color:green">work </span></mark> for <mark><span style="color:green">SREs and product developers </span></mark>, because <mark><span style="color:green">they </span></mark> reflect <mark><span style="color:green">what </span></mark> <mark><span style="color:green">users </span></mark> care about. <mark><span style="color:green">A good SLO </span></mark> is <mark><span style="color:green">a helpful, legitimate forcing function </span></mark> for <mark><span style="color:green">a development team </span></mark>. But <mark><span style="color:green">a poorly thought-out SLO </span></mark> can result in <mark><span style="color:green">wasted work </span></mark> if <mark><span style="color:green">a team </span></mark> uses <mark><span style="color:green">heroic efforts </span></mark> to meet <mark><span style="color:green">an overly aggressive SLO </span></mark>, or <mark><span style="color:green">a bad product </span></mark> if <mark><span style="color:green">the SLO </span></mark> is too lax. <mark><span style="color:green">SLOs </span></mark> are <mark><span style="color:green">a massive lever </span></mark>: use <mark><span style="color:green">them </span></mark> wisely.


# <mark><span style="color:green"> </span></mark># <mark><span style="color:green"> </span></mark> Control Measures

SLIs and SLOs are crucial elements in the control loops used to manage systems:

Monitor and measure <mark><span style="color:green">the system </span></mark>’s <mark><span style="color:green">SLIs </span></mark>.
Compare <mark><span style="color:green">the SLIs </span></mark> to <mark><span style="color:green">the SLOs </span></mark>, and decide whether or not <mark><span style="color:green">action </span></mark> is needed.
If <mark><span style="color:green">action </span></mark> is needed, figure out <mark><span style="color:green">what </span></mark> needs to happen in <mark><span style="color:green">order </span></mark> to meet <mark><span style="color:green">the target </span></mark>.
Take <mark><span style="color:green">that action </span></mark>.

For <mark><span style="color:green">example </span></mark>, if <mark><span style="color:green">step </span></mark> 2 shows that <mark><span style="color:green">request latency </span></mark> is increasing, and will miss <mark><span style="color:green">the SLO </span></mark> in <mark><span style="color:green">a few hours </span></mark> unless <mark><span style="color:green">something </span></mark> is done, <mark><span style="color:green">step </span></mark> 3 might include testing <mark><span style="color:green">the hypothesis </span></mark> that <mark><span style="color:green">the servers </span></mark> are CPU-bound, and deciding to add more of <mark><span style="color:green">them </span></mark> to spread <mark><span style="color:green">the load </span></mark>. Without <mark><span style="color:green">the SLO </span></mark>, <mark><span style="color:green">you </span></mark> wouldn’t know whether (or when) to take <mark><span style="color:green">action </span></mark>.


# <mark><span style="color:green"> </span></mark># <mark><span style="color:green"> </span></mark> SLOs Set Expectations

<mark><span style="color:green">Publishing SLOs </span></mark> sets <mark><span style="color:green">expectations </span></mark> for <mark><span style="color:green">system behavior </span></mark>. <mark><span style="color:green">Users </span></mark> (and <mark><span style="color:green">potential users </span></mark>) often want to know <mark><span style="color:green">what </span></mark> <mark><span style="color:green">they </span></mark> can expect from <mark><span style="color:green">a service </span></mark> in <mark><span style="color:green">order </span></mark> to understand whether <mark><span style="color:green">it </span></mark>’s appropriate for <mark><span style="color:green">their use case </span></mark>. For <mark><span style="color:green">instance </span></mark>, <mark><span style="color:green">a team </span></mark> wanting to build <mark><span style="color:green">a photo-sharing website </span></mark> might want to avoid using <mark><span style="color:green">a service </span></mark> that promises <mark><span style="color:green">very strong durability </span></mark> and <mark><span style="color:green">low cost </span></mark> in <mark><span style="color:green">exchange </span></mark> for <mark><span style="color:green">slightly lower availability </span></mark>, though <mark><span style="color:green">the same service </span></mark> might be <mark><span style="color:green">a perfect fit </span></mark> for <mark><span style="color:green">an archival records management system </span></mark>.
In <mark><span style="color:green">order </span></mark> to set <mark><span style="color:green">realistic expectations </span></mark> for <mark><span style="color:green"><mark><span style="color:green">you </span></mark>r users </span></mark>, <mark><span style="color:green">you </span></mark> might consider using one or both of <mark><span style="color:green">the following tactics </span></mark>:

Keep <mark><span style="color:green">a safety margin </span></mark>
Using <mark><span style="color:green">a tighter internal SLO </span></mark> than <mark><span style="color:green">the SLO </span></mark> advertised to <mark><span style="color:green">users </span></mark> gives <mark><span style="color:green">you </span></mark> <mark><span style="color:green">room </span></mark> to respond to <mark><span style="color:green">chronic problems </span></mark> before <mark><span style="color:green">they </span></mark> become visible externally. <mark><span style="color:green">An SLO buffer </span></mark> also makes <mark><span style="color:green">it </span></mark> possible to accommodate <mark><span style="color:green">reimplementations </span></mark> that trade performance for <mark><span style="color:green">other attributes </span></mark>, such as <mark><span style="color:green">cost </span></mark> or <mark><span style="color:green">ease </span></mark> of <mark><span style="color:green">maintenance </span></mark>, w<mark><span style="color:green">it </span></mark>hout having to disappoint <mark><span style="color:green">users </span></mark>.
Don’t overachieve
<mark><span style="color:green">Users </span></mark> build on <mark><span style="color:green">the reality </span></mark> of <mark><span style="color:green"><mark><span style="color:green">what </span></mark> </span></mark> <mark><span style="color:green"><mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> </span></mark> offer, rather than <mark><span style="color:green"><mark><span style="color:green">what </span></mark> </span></mark> <mark><span style="color:green"><mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> </span></mark> say <mark><span style="color:green"><mark><span style="color:green"><mark><span style="color:green">you </span></mark> </span></mark> </span></mark>’ll supply, particularly for <mark><span style="color:green">infrastructure services </span></mark>. If <mark><span style="color:green">your service </span></mark>’s <mark><span style="color:green">actual performance </span></mark> is much better than <mark><span style="color:green">its stated SLO </span></mark>, <mark><span style="color:green">users </span></mark> will come to rely on <mark><span style="color:green">its current performance </span></mark>. <mark><span style="color:green">You </span></mark> can avoid <mark><span style="color:green">over-dependence </span></mark> by deliberately taking <mark><span style="color:green"><mark><span style="color:green">the system </span></mark> offline </span></mark> occasionally (<mark><span style="color:green">Google’s Chubby service </span></mark> introduced <mark><span style="color:green">planned outages </span></mark> in <mark><span style="color:green">response </span></mark> to being overly available),18 throttling <mark><span style="color:green">some requests </span></mark>, or designing <mark><span style="color:green">the system </span></mark> so that <mark><span style="color:green">it </span></mark> isn’t faster under <mark><span style="color:green">light loads </span></mark>.

Understanding how well <mark><span style="color:green">a system </span></mark> is meeting <mark><span style="color:green">its expectations </span></mark> helps decide whether to invest in making <mark><span style="color:green">the system </span></mark> faster, more available, and more resilient. Alternatively, if <mark><span style="color:green">the service </span></mark> is doing fine, perhaps <mark><span style="color:green">staff time </span></mark> should be spent on <mark><span style="color:green">other priorities </span></mark>, such as paying off <mark><span style="color:green">technical debt </span></mark>, adding <mark><span style="color:green">new features </span></mark>, or introducing <mark><span style="color:green">other products </span></mark>.<mark><span style="color:green">Agreements </span></mark> in <mark><span style="color:green">Practice </span></mark>
Crafting <mark><span style="color:green">an SLA </span></mark> requires <mark><span style="color:green">business and legal teams </span></mark> to pick <mark><span style="color:green">appropriate consequences </span></mark> and <mark><span style="color:green">penalties </span></mark> for <mark><span style="color:green">a breach </span></mark>. <mark><span style="color:green">SRE’s role </span></mark> is to help <mark><span style="color:green">them </span></mark> understand <mark><span style="color:green">the likelihood </span></mark> and <mark><span style="color:green">difficulty </span></mark> of meeting <mark><span style="color:green">the SLOs </span></mark> contained in <mark><span style="color:green">the SLA </span></mark>. Much of <mark><span style="color:green">the advice </span></mark> on <mark><span style="color:green">SLO construction </span></mark> is also applicable for <mark><span style="color:green">SLAs </span></mark>. <mark><span style="color:green">It </span></mark> is wise to be conservative in <mark><span style="color:green">what </span></mark> <mark><span style="color:green">you </span></mark> advertise to <mark><span style="color:green">users </span></mark>, as the broader <mark><span style="color:green">the const<mark><span style="color:green">it </span></mark>uency </span></mark>, the harder <mark><span style="color:green">it </span></mark> is to change or delete SLAs that prove to be unwise or difficult to work w<mark><span style="color:green">it </span></mark>h.

16Most <mark><span style="color:green">people </span></mark> really mean <mark><span style="color:green">SLO </span></mark> when <mark><span style="color:green">they </span></mark> say "<mark><span style="color:green">SLA </span></mark>." One giveaway: if <mark><span style="color:green">somebody </span></mark> talks about <mark><span style="color:green">an "SLA violation </span></mark>," <mark><span style="color:green">they </span></mark> are almost always talking about <mark><span style="color:green">a missed SLO </span></mark>. <mark><span style="color:green">A real SLA violation </span></mark> might trigger <mark><span style="color:green">a court case </span></mark> for <mark><span style="color:green">breach </span></mark> of contract.17If <mark><span style="color:green">you </span></mark> can’t ever win <mark><span style="color:green">a conversation </span></mark> about <mark><span style="color:green">SLOs </span></mark>, <mark><span style="color:green">it </span></mark>’s probably not worth having <mark><span style="color:green">an SRE team </span></mark> for <mark><span style="color:green">the product.18Failure injection </span></mark> [<mark><span style="color:green">Ben12 </span></mark>] serves <mark><span style="color:green">a different purpose </span></mark>, but can also help set <mark><span style="color:green">expectations </span></mark>.




```python

```


```python

```
